{"version":3,"file":"Cluster.js","sources":["../../../src/ol/source/Cluster.js"],"sourcesContent":["/**\n * @module ol/source/Cluster\n */\n\nimport {getUid} from '../util.js';\nimport {assert} from '../asserts.js';\nimport Feature from '../Feature.js';\nimport {scale as scaleCoordinate, add as addCoordinate} from '../coordinate.js';\nimport {listen} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {buffer, createEmpty, createOrUpdateFromCoordinate} from '../extent.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from '../source/Vector.js';\n\n/**\n * @typedef {Object} Options\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Minimum distance in pixels between clusters.\n * @property {module:ol/extent~Extent} [extent] Extent.\n * @property {function(module:ol/Feature):module:ol/geom/Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underyling source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {module:ol/proj~ProjectionLike} projection Projection.\n * @property {module:ol/source/Vector} source Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n * @api\n */\nclass Cluster extends VectorSource {\n  /**\n   * @param {module:ol/source/Cluster~Options=} options Cluster options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      extent: options.extent,\n      projection: options.projection,\n      wrapX: options.wrapX\n    });\n\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.resolution = undefined;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.distance = options.distance !== undefined ? options.distance : 20;\n\n    /**\n     * @type {Array.<module:ol/Feature>}\n     * @protected\n     */\n    this.features = [];\n\n    /**\n     * @param {module:ol/Feature} feature Feature.\n     * @return {module:ol/geom/Point} Cluster calculation point.\n     * @protected\n     */\n    this.geometryFunction = options.geometryFunction || function(feature) {\n      const geometry = /** @type {module:ol/geom/Point} */ (feature.getGeometry());\n      assert(geometry instanceof Point,\n        10); // The default `geometryFunction` can only handle `module:ol/geom/Point~Point` geometries\n      return geometry;\n    };\n\n    /**\n     * @type {module:ol/source/Vector}\n     * @protected\n     */\n    this.source = options.source;\n\n    listen(this.source, EventType.CHANGE, this.refresh, this);\n  }\n\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  getDistance() {\n    return this.distance;\n  }\n\n  /**\n   * Get a reference to the wrapped source.\n   * @return {module:ol/source/Vector} Source.\n   * @api\n   */\n  getSource() {\n    return this.source;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  loadFeatures(extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.clear();\n      this.resolution = resolution;\n      this.cluster();\n      this.addFeatures(this.features);\n    }\n  }\n\n  /**\n   * Set the distance in pixels between clusters.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  setDistance(distance) {\n    this.distance = distance;\n    this.refresh();\n  }\n\n  /**\n   * handle the source changing\n   * @override\n   */\n  refresh() {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n    VectorSource.prototype.refresh.call(this);\n  }\n\n  /**\n   * @protected\n   */\n  cluster() {\n    if (this.resolution === undefined) {\n      return;\n    }\n    this.features.length = 0;\n    const extent = createEmpty();\n    const mapDistance = this.distance * this.resolution;\n    const features = this.source.getFeatures();\n\n    /**\n     * @type {!Object.<string, boolean>}\n     */\n    const clustered = {};\n\n    for (let i = 0, ii = features.length; i < ii; i++) {\n      const feature = features[i];\n      if (!(getUid(feature).toString() in clustered)) {\n        const geometry = this.geometryFunction(feature);\n        if (geometry) {\n          const coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n\n          let neighbors = this.source.getFeaturesInExtent(extent);\n          neighbors = neighbors.filter(function(neighbor) {\n            const uid = getUid(neighbor).toString();\n            if (!(uid in clustered)) {\n              clustered[uid] = true;\n              return true;\n            } else {\n              return false;\n            }\n          });\n          this.features.push(this.createCluster(neighbors));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array.<module:ol/Feature>} features Features\n   * @return {module:ol/Feature} The cluster feature.\n   * @protected\n   */\n  createCluster(features) {\n    const centroid = [0, 0];\n    for (let i = features.length - 1; i >= 0; --i) {\n      const geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        addCoordinate(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    scaleCoordinate(centroid, 1 / features.length);\n\n    const cluster = new Feature(new Point(centroid));\n    cluster.set('features', features);\n    return cluster;\n  }\n}\n\n\nexport default Cluster;\n"],"names":["super","const","let","this"],"mappings":"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"}